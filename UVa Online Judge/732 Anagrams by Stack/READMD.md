# 732 Anagrams by Stack

## Time Limit Error 이유

- 옛날 문제라서 그런지 인풋 사이즈를 안알려줬다. 그런데 완전탐색 문제라서 n이 엄청 클것같지는 않길래 인풋 사이즈가 최대 15정도일것이라고 가정하고 i를 1 o를 0으로 해서 비트패턴을 활용해서 풀어보려고 했는데 시간초과가 났다.
  - 시간 초과로 뜨는것을 보면 답은 맞춘것 같은데, 내가 가정한 인풋보다 큰 인풋이 와서 무슨 문제가 생긴것인지 실제 시간초과인지를 모르겠다. 최적화 하겠다고 비트연산을 사용해서 풀어본것인데 말이다.
- 일단 TLE가 난 문제풀이에서 가지치기를 한 완전탐색은 정확히 구현했다.

## string을 사용

- 알고리즘 문제를 풀때 빠른 수행시간을 위해서 c-string과 printf를 즐겨 사용하는 편인데, 인풋사이즈를 알 수 없는 관계로 string 클래스와 cin을 활용해서 인풋을 받았다.
- 완전 탐색문제는 보통 dfs로 풀리기 때문에, 재귀 함수를 사용한 문제풀이를 했다.
  - 보통은 재귀함수도 시간 많이걸릴까봐 잘 안쓰려고 하지만, 재귀 없이 직접 스택을 구현해서 상태를 저장하기에는 유지해야하는 상태가 너무 많았다.
- 알파벳 상으로 i가 o보다 먼저 오기때문에, i와 o중 i를 먼저 추가하는 방식으로 탐색해 나가면 사전순 앞인 결과가 먼저 나온다.
- 유지해야하는 상태는, 1. 결과로나오는 단어, 2. operation sequence, 3. 스택, 4. 현재 소스 단어의 어디를 가리키는지 인덱스, 5. 현재 타겟 단어의 어디를 가리키는지 인덱스로 5가지이다.
- 가능한 i, o 시퀀스를 모두 방문한다면 시간이 너무 오래 걸리므로 가지치기를 한다.
  - 1. source와 target의 길이가 다르면 검색하지 않는다.
  - 2. 길이가 같더라도 구성 알파벳이 다르면 검색하지 않는다.
  - 3. 1과 2를 통과하면 완전탐색을 시작한다. 완전 탐색 중에서도 몇가지 가지치기를 한다.
    - 1. push할 source의 알파벡이 없으면 멈춘다.(i가 소스의 길이 초과로 나오는 경우)
    - 2. stack이 비어있는데 pop하려고하면 멈춘다.(i가 나오기전 o가 나오는경우)
    - 3. pop하려고 하는데 스택의 top이 target의 알파벳과 다른경우(매칭 안되는경우)
- 재귀적으로 탐색을 하다가, anagram이 만들어 졌으면 생성된 operation sequence를 출력하는 것이다.
