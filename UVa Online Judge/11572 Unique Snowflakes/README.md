# 11572 Unique Snowflakes

## 문제 해석

- 눈송이의 열이 주어진다. 눈송이는 일렬로 들어오고, 눈송이에는 0 ~ 10^9까지의 id가 주어진다. 눈송이가 중복되어 들어오는 경우가 있다.
- 일렬로 들어오는 눈송이를 한 package에 담으려고 하는데, 패키지 안에는 각기 다른 종류의 눈송이(id가 겹치지 않는 눈송이)만 넣고 싶다.
- 가장 많은 눈송이의 종류를 넣을수 있는 package에 들어간 눈송이의 종류를 출력한다.

## 문제 풀이

### 알고리즘 최적화 - 첫번째

- 첫번째 시도에서의 알고리즘은 이중 for문 기반이었다. 1번 눈송이부터 시작해서 겹치지 않을때까지 패키지에 담아보고, 겹치는게 나오면 다시 2번눈송이부터 담아보고 하면서 최대 개수를 구하는것이다.
- 여기서 최적화를 한것은 만약 현재까지 구한 최대값이 max이고, 눈송이 열의 길이가 len일때, len - max 번째 눈송이까지만 알고리즘을 진행하는 것이다. len - max번째 눈송이부터 끝가지 하나도 겹친는 눈송이가 없다면 패키지에 담을수 있는 개수가 max개가 된다. 그렇기 때문에 그 이후는 구하지 않아도 현재까지 구한 max가 최대임을 알수있다.
- TLE가 났다.

### TLE 해결 시도 1 - cin, cout을 printf, scanf로 바꿔본다.

- 여전히 TLE, 입출력 문제는 아니다.

### TLE 해결 시도 2 - vector와 unordered_map에서 reserve 사용하기

- 여전히 TLE, 컨테이너 용량을 늘리느라 걸리는 시간은 크지 않은것 같다.
  - 현업에서는 vector는 꼭 reserve하도록 한다고 함. vector를 자꾸 확장하다 보면 메모리 파편화 현상도 심해지고 오버헤드가 있기 때문인데, 이 문제는 입력 개수가 그렇게 많지 않았을수도 있고, 아니면 서버에서 알고리즘 채점만 하기때문에 그런걸수도 있다.
- reserve없이 AC받고나서 reserve를 해봤는데, 시간이 빨리지지 않았음. 오히려 크게 reserve 했을때 초반에 메모리를 잡느라 시간이 많이 늘어낳다.

### TLE 해결 시도 3 - 알고리즘 최적화 - 성공

- i 번째 눈송이부터 패키지에 눈송이를 넣다가 j번째 에서 겹치는 눈송이가 나왔다고 가정하자. 이 때 i + 1번째 눈송이부터 다시 계산하는 것은 오버헤드가 너무 크다.
- 만약 i + 1 번째 눈송이가 j번째 눈송이랑 다르다면, i + 1 번째 부터 패키지에 넣으면 똑같이 j번째에서 실패 할것이고 이때 패키지에 넣은 눈송이의 개수는 i번째 눈송이부터 넣었을 때 보다 1개 작을것이다. 이경우는 불필요한 계산이다.
- 만약 i + 1 번째 눈송이가 j번째 눈송이랑 같다면, i + 2번째 부터 패키지에 넣기 시작한다면 j번째에서 겹치지 않고 그 다음으로 이어서 갈수 있다.
- 결과적으로, j번째에서 겹쳤을때, j번째 눈송이와 같은 눈송이가 k번째에 나왔다면 k + 1번째 부터 다시 계산을 해야 더 많은 눈송이를 넣을 가능성이 있다.

## 알고리즘

- 인풋을 벡터에 받는다. 인풋의 최대 크기가 정해져있지 않아서 어쩔수 없다.
- 눈송이가 나왔는지 안나왔는지 확인하기 위한 해시테이블(unordered_map)을 만들어 놓는다.
- 첫번째 눈송이부터 시작해서 패키지에 담는다. 이미 패키지에 담았는지 알아보기 위해서 해시테이블을 사용한다. 해시테이블의 키로 눈송이의 id를 사용하고, 밸류로는 해당 눈송이의 index를 저장한다.
- 패키지에 겹치는 눈송이가 존재하면, 해시테이블에서 겹치는 눈송이 어느 index에서 나왔는지 확인한다. 그 index + 1부터 시작해서 다시 패키지에 담아본다.
